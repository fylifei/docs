---
title: "Closures: How Functions Remember Their Scope in JavaScript"
sidebarTitle: "Closures: How Functions Remember Their Scope"
description: "Learn JavaScript closures and how functions remember their scope. Covers lexical scoping, practical use cases, memory considerations, and common closure patterns."
---

Why do some functions seem to "remember" variables that should have disappeared? How can a callback still access variables from a function that finished running long ago?

The answer is **closures** â€” one of JavaScript's most powerful (and often misunderstood) features. A closure is a function that retains access to its outer scope's variables, even after that outer scope has finished executing.

```javascript
function createCounter() {
  let count = 0  // This variable is "enclosed" by the returned function
  return function() {
    count++
    return count
  }
}

const counter = createCounter()
console.log(counter())  // 1
console.log(counter())  // 2 â€” it remembers!
```

Understanding closures unlocks patterns like private variables, factory functions, and the module pattern that power modern JavaScript.

<Info>
**What you'll learn in this guide:**
- What closures actually are and how they work
- Why closures matter in JavaScript development
- Practical use cases for closures in real code
- Common closure patterns and best practices
- Memory considerations and potential pitfalls
</Info>

---

## What is a Closure in JavaScript?

A **closure** is created when a function is defined inside another function, and the inner function accesses variables from the outer function. Even after the outer function returns, the inner function maintains access to those variables through its closure.

This happens because JavaScript functions maintain a reference to their lexical environment â€” the scope where they were created.

```javascript
function outerFunction() {
  let outerVar = "I'm from outer"

  function innerFunction() {
    console.log(outerVar)  // Accesses outerVar via closure
  }

  return innerFunction
}

const myClosure = outerFunction()
myClosure()  // "I'm from outer" â€” even though outerFunction finished!
```

The key insight: functions don't just contain code â€” they also carry their surrounding environment with them.

---

## The Backpack Analogy

Think of a closure like a backpack that a function carries around. When a function is created inside another function, it packs up all the variables from its outer scope into this invisible backpack.

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         THE BACKPACK ANALOGY                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚    OUTER FUNCTION (The Factory)                                          â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚    â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚  â”‚
â”‚    â”‚  â”‚  let count = 0                                          â”‚   â”‚  â”‚
â”‚    â”‚  â”‚  let name = "counter"                                   â”‚   â”‚  â”‚
â”‚    â”‚  â”‚                                                          â”‚   â”‚  â”‚
â”‚    â”‚  â”‚  function inner() {  â† Packs backpack with these vars!   â”‚   â”‚  â”‚
â”‚    â”‚  â”‚    return count + 1                                     â”‚   â”‚  â”‚
â”‚    â”‚  â”‚  }                                                      â”‚   â”‚  â”‚
â”‚    â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚  â”‚
â”‚    â”‚                                                                 â”‚  â”‚
â”‚    â”‚  return inner  â† Sends function with its backpack               â”‚  â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                              â”‚                                            â”‚
â”‚                              â–¼                                            â”‚
â”‚    INNER FUNCTION (The Traveler)                                          â”‚
â”‚    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚    â”‚  ğŸ”’ BACKPACK: [count=0, name="counter"]                         â”‚  â”‚
â”‚    â”‚                                                                  â”‚  â”‚
â”‚    â”‚  Can access these variables ANYWHERE, even after outer        â”‚  â”‚
â”‚    â”‚  function has finished!                                         â”‚  â”‚
â”‚    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

The backpack travels with the function wherever it goes, keeping those variables alive and accessible.

---

## How Closures Work Under the Hood

When JavaScript creates a closure, it allocates memory for the variables in the outer scope and ensures they're not garbage collected as long as something references them.

### Lexical Scoping

JavaScript uses **lexical scoping** â€” a function's scope is determined by where it's written in the code, not where it's called from.

```javascript
function createGreeter(greeting) {
  // greeting is captured in the closure
  return function(name) {
    console.log(`${greeting}, ${name}!`)
  }
}

const sayHello = createGreeter("Hello")
const sayHi = createGreeter("Hi")

sayHello("Alice")  // "Hello, Alice!"
sayHi("Bob")       // "Hi, Bob!"
```

Each `createGreeter` call creates a new closure with its own `greeting` variable.

<Tip>
**Quick Rule of Thumb:** If a function uses variables from outside itself, and those variables come from a function that has already returned, you're working with a closure.
</Tip>

---

## Common Closure Patterns

### 1. Private Variables

JavaScript doesn't have built-in private properties, but closures give us a way to create them:

```javascript
function createBankAccount(initialBalance) {
  let balance = initialBalance  // Private variable

  return {
    deposit(amount) {
      balance += amount
      return balance
    },
    withdraw(amount) {
      if (amount > balance) {
        throw new Error("Insufficient funds")
      }
      balance -= amount
      return balance
    },
    getBalance() {
      return balance  // Read-only access
    }
  }
}

const account = createBankAccount(100)
console.log(account.getBalance())  // 100
account.deposit(50)
console.log(account.getBalance())  // 150
// account.balance is undefined â€” can't access directly!
```

### 2. Function Factories

Create customized functions based on parameters:

```javascript
function createMultiplier(factor) {
  return function(number) {
    return number * factor
  }
}

const double = createMultiplier(2)
const triple = createMultiplier(3)

console.log(double(5))   // 10
console.log(triple(5))   // 15
```

### 3. Event Handlers

Closures are everywhere in event handling:

```javascript
function setupButtons() {
  let clickCount = 0

  document.getElementById('myButton').addEventListener('click', function() {
    clickCount++
    console.log(`Button clicked ${clickCount} times`)
  })
}

setupButtons()
```

The callback function maintains access to `clickCount` through its closure.

---

## Closures in the Wild

### setTimeout and setInterval

```javascript
function delayedLogger(message, delay) {
  setTimeout(function() {
    console.log(message)  // message is captured by closure
  }, delay)
}

delayedLogger("Hello after 1 second!", 1000)
```

### Array Methods

```javascript
const users = [
  { name: "Alice", age: 25 },
  { name: "Bob", age: 30 },
  { name: "Charlie", age: 35 }
]

function filterByAge(minAge) {
  // minAge is captured by the closure passed to filter
  return users.filter(user => user.age >= minAge)
}

console.log(filterByAge(30))  // [{name: "Bob", age: 30}, {name: "Charlie", age: 35}]
```

---

## Common Closure Mistakes

### The Loop Problem (Classic Interview Question)

```javascript
// âŒ WRONG â€” All buttons log "5"
for (var i = 1; i <= 5; i++) {
  setTimeout(function() {
    console.log(i)  // What does this log?
  }, 100)
}

// Output: 5, 5, 5, 5, 5 (all the same!)
```

<Warning>
**The Trap:** `var` is function-scoped, not block-scoped. All closures share the same `i` variable, which ends up as 6 when the callbacks run.
</Warning>

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         THE LOOP PROBLEM VISUALIZED                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚                                                                          â”‚
â”‚  WRONG WAY (var)                           RIGHT WAY (let)               â”‚
â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€                                  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€                    â”‚
â”‚                                                                          â”‚
â”‚  All closures share ONE "i" variable      Each closure has its OWN "i"   â”‚
â”‚                                                                          â”‚
â”‚  Closure 1 â”€â”€â”€â”                         Closure 1 â”€â”€â”€â–º i = 1            â”‚
â”‚  Closure 2 â”€â”€â”€â”¼â”€â”€â–º i = 6                 Closure 2 â”€â”€â”€â–º i = 2            â”‚
â”‚  Closure 3 â”€â”€â”€â”¤                         Closure 3 â”€â”€â”€â–º i = 3            â”‚
â”‚  Closure 4 â”€â”€â”€â”˜                         Closure 4 â”€â”€â”€â–º i = 4            â”‚
â”‚                                         Closure 5 â”€â”€â”€â–º i = 5            â”‚
â”‚  Result: 6, 6, 6, 6, 6                   Result: 1, 2, 3, 4, 5          â”‚
â”‚                                                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Fixes for the Loop Problem

**Fix 1: Use `let` (Recommended)**

```javascript
// âœ“ CORRECT â€” let is block-scoped
for (let i = 1; i <= 5; i++) {
  setTimeout(function() {
    console.log(i)  // 1, 2, 3, 4, 5
  }, 100)
}
```

**Fix 2: Create a new scope with IIFE**

```javascript
// âœ“ ALSO CORRECT â€” Creates new scope per iteration
for (var i = 1; i <= 5; i++) {
  (function(j) {
    setTimeout(function() {
      console.log(j)  // 1, 2, 3, 4, 5
    }, 100)
  })(i)
}
```

**Fix 3: Use `bind`**

```javascript
// âœ“ ALSO CORRECT â€” Binds the value
for (var i = 1; i <= 5; i++) {
  setTimeout(function(j) {
    console.log(j)  // 1, 2, 3, 4, 5
  }.bind(null, i), 100)
}
```

---

## Memory Considerations

### When Closures Cause Memory Leaks

Closures keep variables alive as long as the function exists. Sometimes this causes problems:

```javascript
function createHugeDataHolder() {
  const hugeArray = new Array(1000000).fill("data")

  return function() {
    console.log("I still hold a reference to hugeArray!")
  }
}

const holder = createHugeDataHolder()
// hugeArray stays in memory until holder is garbage collected
```

### Best Practices

1. **Avoid unnecessary closures** in performance-critical code
2. **Let closures go out of scope** when you're done with them
3. **Be careful with closures in loops** that create many functions
4. **Use weak references** (WeakMap, WeakSet) when appropriate

```javascript
// Good: Closure released when no longer needed
function createCounter() {
  let count = 0
  return {
    increment() { count++ },
    getCount() { return count }
  }
}

// When you're done with the counter, set it to null
let counter = createCounter()
counter.increment()
counter = null  // Closure can now be garbage collected
```

---

## Key Takeaways

<Info>
**The key things to remember:**

1. **Closures give functions memory** â€” A function remembers variables from its outer scope, even after that outer function returns.

2. **Closures are created automatically** â€” Whenever an inner function accesses variables from an outer function, a closure is created.

3. **Closures enable powerful patterns** â€” Private variables, function factories, and event handlers all rely on closures.

4. **Beware of the loop problem** â€” Using `var` in loops with closures creates shared variables. Use `let` instead.

5. **Closures have memory implications** â€” Variables in closures stay in memory as long as the closure exists. Be mindful in performance-critical code.

6. **Closures are everywhere** â€” If you use callbacks, event handlers, or array methods like `map` and `filter`, you're already using closures.

7. **Closures enable data privacy** â€” They're the closest JavaScript gets to private variables before private class fields.

8. **Each function call creates a new scope** â€” Multiple calls to a factory function create independent closures with their own variables.

9. **Arrow functions work the same** â€” `() => {}` creates closures just like `function() {}` does.

10. **Understanding closures makes you a better developer** â€” They're fundamental to modern JavaScript patterns like React hooks, middleware, and more.
</Info>

---

## Test Your Knowledge

<AccordionGroup>
  <Accordion title="Question 1: What is a closure?">
    **Answer:**
    
    A closure is a function that retains access to variables from its outer (enclosing) scope, even after that outer function has finished executing. Closures are automatically created when an inner function accesses variables from an outer function.

    ```javascript
    function outer() {
      let x = 10
      return function inner() {
        return x  // Creates a closure over x
      }
    }
    ```

    Key point: the inner function "remembers" `x` even after `outer()` returns.
  </Accordion>
  
  <Accordion title="Question 2: What's the output of this code?">
    **Answer:**
    
    ```javascript
    for (var i = 0; i < 3; i++) {
      setTimeout(() => console.log(i), 0)
    }
    ```
    
    Output: `3, 3, 3`
    
    Why? `var` is function-scoped, so all three closures share the same `i` variable. By the time the callbacks run, the loop has finished and `i` is 3.
  </Accordion>
  
  <Accordion title="Question 3: How would you fix the loop problem?">
    **Answer:**
    
    Use `let` instead of `var`:
    
    ```javascript
    for (let i = 0; i < 3; i++) {
      setTimeout(() => console.log(i), 0)
    }
    // Output: 0, 1, 2
    ```
    
    `let` is block-scoped, so each iteration gets its own `i`. Each closure captures its own unique value.
  </Accordion>
  
  <Accordion title="Question 4: Can closures cause memory leaks?">
    **Answer:**
    
    Yes. Closures keep variables alive as long as the function exists. If you create many closures or keep references to large objects unnecessarily, you can prevent garbage collection.
    
    Example:
    ```javascript
    function createLeaky() {
      const hugeData = new Array(1000000).fill("x")
      return function() {
        console.log("exists")
      }
    }
    
    const leaky = createLeaky()
    // hugeData stays in memory until leaky is released
    ```
  </Accordion>
  
  <Accordion title="Question 5: How do closures enable private variables?">
    **Answer:**
    
    By returning an object with methods but not exposing the variables directly:
    
    ```javascript
    function createCounter() {
      let count = 0  // Private
      return {
        increment() { count++ },
        getCount() { return count }
        // count is not accessible from outside
      }
    }
    
    const counter = createCounter()
    counter.increment()
    console.log(counter.getCount())  // 1
    // counter.count is undefined
    ```
    
    The only way to access `count` is through the provided methods.
  </Accordion>
</AccordionGroup>

---

## Related Concepts

<CardGroup cols={2}>
  <Card title="Scope and Variable Hoisting" icon="layers" href="/concepts/scope">
    Understanding lexical scope is foundational to understanding how closures work
  </Card>
  <Card title="Functions as First-Class Citizens" icon="code" href="/concepts/functions">
    Functions can be passed around and returned, which enables closure patterns
  </Card>
  <Card title="The Event Loop" icon="arrows-spin" href="/concepts/event-loop">
    Closures work with the event loop in callbacks and asynchronous code
  </Card>
  <Card title="Array Methods" icon="list" href="/concepts/array-methods">
    map, filter, and reduce all use closures to access array elements
  </Card>
</CardGroup>

---

## Reference

<CardGroup cols={2}>
  <Card title="Closures â€” MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures">
    Official MDN documentation explaining closures with examples
  </Card>
  <Card title="Functions â€” MDN" icon="book" href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions">
    Comprehensive guide to functions, including closure behavior
  </Card>
</CardGroup>

## Articles

<CardGroup cols={2}>
  <Card title="Understanding Closures in JavaScript" icon="newspaper" href="https://www.digitalocean.com/community/tutorials/understanding-closures-in-javascript">
    Clear, beginner-friendly introduction to closures with practical examples
  </Card>
  <Card title="JavaScript Closures Explained by Examples" icon="newspaper" href="https://medium.com/dailyjs/i-never-understood-javascript-closures-9b37009cbccc">
    Visual explanations that make closures click with relatable analogies
  </Card>
  <Card title="Mastering JavaScript Closures" icon="newspaper" href="https://javascript.info/closure">
    In-depth coverage from javascript.info, including practical use cases
  </Card>
  <Card title="A Simple Guide to JavaScript Closures" icon="newspaper" href="https://www.freecodecamp.org/news/a-simple-guide-to-javascript-closures/">
    FreeCodeCamp's guide with step-by-step examples and common pitfalls
  </Card>
</CardGroup>

## Videos

<CardGroup cols={2}>
  <Card title="JavaScript Closures Explained" icon="video" href="https://www.youtube.com/watch?v=71AtaCp9Fg4">
    Web Dev Simplified breaks down closures with clear examples in under 10 minutes
  </Card>
  <Card title="Understanding Closures" icon="video" href="https://www.youtube.com/watch?v=qikxEIxsXto">
    Fun Fun Function's deep dive into closure theory and practical applications
  </Card>
  <Card title="JavaScript Closures - The Beginner's Guide" icon="video" href="https://www.youtube.com/watch?v=3a0I2ICq2fY">
    Beginner-focused tutorial with real-world examples and code breakdowns
  </Card>
  <Card title="Closures in 100 Seconds" icon="video" href="https://www.youtube.com/watch?v=qikxEIxsXto">
    Fireship's fast-paced overview perfect for quick refreshers
  </Card>
</CardGroup>
